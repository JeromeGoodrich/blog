---
layout: post
title: Dependency Inversion in Java
date: 2016-03-08 22:57:17.000000000 -06:00
type: post
published: true
status: publish
categories: []
tags: []
meta:
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '20567405121'
author:
  login: jgoodrich7
  email: jeromegoodrich@gmail.com
  display_name: jgoodrich7
  first_name: ''
  last_name: ''
---
<p>There are two things that stuck with me from my last IPM: creating short feedback loops, and dependency inversion.  I wrote about feedback  yesterday, so today I'll try and tackle dependency inversion and how I attempted to create it in my JAVA HTTP server.</p>
<p>The principle of dependency inversion simply states that the more a thing changes the less other things should depend on it and that the more stable something is the more other things can depend on it. Typically, the more abstract something is the more stable it becomes. Conversely the more concrete something is the more it is likely to change.</p>
<p>In JAVA this distinction is made rather explicit. Abstract classes and interfaces are abstract, and the classes that implement them are more concrete. A JAVA method or class that uses instances of these classes by either having them as a dependency in the arguments to a method or instantiating an instance of them within the method are said to have concrete dependencies, which means that if we had to change one of those concretions we'd also have to change all the methods that depend on it. Take a look at my original WebService class:</p>
<p>[code language="java"]<br />
public class WebService implements Runnable {</p>
<p>private Socket clientSocket;</p>
<p>public WebService(Socket clientSocket) {<br />
  this.clientSocket = clientSocket;<br />
}</p>
<p>  public void run() {<br />
    try {<br />
      DataOutputStream outToClient = new                 DataOutputStream(clientSocket.getOutputStream());<br />
      InputStreamReader inputReader = new    InputStreamReader(clientSocket.getInputStream());<br />
      BufferedReader inFromClient = new BufferedReader(inputReader);</p>
<p>      String rawRequest = inFromClient.readLine();<br />
      Request request = new Request();<br />
      request.parse(rawRequest);<br />
      RequestHandler handler = new RequestHandler();<br />
      Response response = handler.handle(request);<br />
      ResponseFormatter formatter = new ResponseFormatter();<br />
      byte[] formattedResponse = formatter.format(response);</p>
<p>      outToClient.write(formattedResponse);<br />
      outToClient.flush();</p>
<p>      clientSocket.close();</p>
<p>    } catch (Exception e) {<br />
      e.printStackTrace();<br />
    }</p>
<p>  }<br />
}<br />
[/code]</p>
<p>There are a ton of concrete dependencies!</p>
<ol>
<li>Socket in the constructor</li>
<li>DataOutputStream</li>
<li>InputStream</li>
<li>BufferedReader</li>
<li>Request</li>
<li>RequestHandler</li>
<li>Response</li>
<li>ResponseFormatter</li>
</ol>
<p>If anyone of these concrete dependencies changed, I would have to alter the run method. In addition, testing the run method with this current implementation is very difficult.</p>
<p>Here's what I have now. It's far from perfect but it reduced the number of concrete dependencies I have from 8 to 1:</p>
<p>[code language="java"]<br />
public class Service implements Runnable {</p>
<p>    private Parser parser;<br />
    private Handler handler;<br />
    private ClientServerIO io;<br />
    private Request request;</p>
<p>    public Service(ClientServerIO io, Handler handler, Parser parser) {<br />
        this.io = io;<br />
        this.parser = parser;<br />
        this.handler = handler;</p>
<p>    }</p>
<p>    public void run() {<br />
        try {</p>
<p>            request = parser.parse(io.inFromClient());<br />
            Response response = handler.handle(request);<br />
            ResponseFormatter formatter = new ResponseFormatter();<br />
            byte[] formattedResponse = formatter.format(response);</p>
<p>            io.outToClient().write(formattedResponse);<br />
            io.outToClient().flush();</p>
<p>            io.close();</p>
<p>        } catch (Exception e) {<br />
            e.printStackTrace();<br />
        }</p>
<p>    }<br />
}<br />
[/code]</p>
<p>The class now has 3 arguments to its constructor. Each of these arguments are interfaces, abstractions which allows me to pass in any class that implements the interface. This is called dependency injection and I found out it is crucial in order to adhere to the dependency inversion principle in JAVA.</p>
<p>The flexibility that comes with this implementation allows this Service to operate independent of of a lot of things, it could be HTTP, FTP or something else as long as it is within a client server model with some tweaks this server should be able to deal with many different kinds of inputs and return many different outputs.</p>
