---
layout: post
title: 'The Long Road: Day 8'
date: 2016-01-21 04:32:42.000000000 -06:00
type: post
published: true
status: publish
categories: []
tags: []
meta:
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '18963134312'
author:
  login: jgoodrich7
  email: jeromegoodrich@gmail.com
  display_name: jgoodrich7
  first_name: ''
  last_name: ''
---
<p>I'm easily intimidated by code. Often I feel like I'm peering through a dark glass. If I squint I can barely make out shady figures on the other side, but I don't understand their intentions. Are they friends or enemies?  90% of the time I mistakenly choose the latter. Every so often, when the light hits just right, I can clearly identify one of these figures and recruit them to my cause. Today I want to talk about one of these rare instances. Today I want to talk about <em>configuration</em>.</p>
<blockquote><p>Configuration - the way the parts of something are arranged</p></blockquote>
<p>It's a word I knew before I started coding and it appears all over the place (usually as "config") when developing software. Yet, until today, it never really dawned on me why. I understood that most things needed some sort of configuration, but I took it at face value.</p>
<p>During my student apprenticeship I had to build a to-do list app that could work online as well as in in the command line. I also had to make sure that the app had tests for both interfaces. The code below is from a file in my todo app called spec_helper.rb</p>
<p>[code language="ruby"] &amp;amp;nbsp;&amp;amp;nbsp;</p>
<p>require 'rack/test'<br />
require 'rspec'</p>
<p>require File.expand_path &quot;../../sinatra_todo_app.rb&quot;, __FILE__</p>
<p>ENV['RACK_ENV'] = 'test'</p>
<p>module RSpecMixin<br />
 include Rack::Test::Methods<br />
 def app() Sinatra::Application end<br />
end</p>
<p>RSpec.configure do |config|<br />
 config.include RSpecMixin<br />
 DataMapper::setup(:default, &quot;sqlite3://#{Dir.pwd}/list_test.db&quot;)<br />
 DataMapper.finalize<br />
 List.auto_migrate!<br />
 Task.auto_migrate!<br />
 User.auto_migrate!<br />
end</p>
<p>[/code]</p>
<p>As I remember, I think I found a version of this code on someone else's blog and hacked away at it until it did what I needed, only (vaguely) understanding after the fact what it was actually doing. Surprise, it's a configuration file! See that</p>
<p>[code language="ruby"] Rspec.configure do |config| [/code]</p>
<p>That's the giveaway. Basically, all that code before are the parts we need to configure the coding library RSpec to do what we want. All that</p>
<p>[code language="ruby"] Rspec.configure do |config| [/code]</p>
<p>is doing is taking those parts and arranging them in the way we want.</p>
<p>&nbsp;</p>
<p>Again, when I first did this, my understanding was a bit more rudimentary. It was more like, "I know that this stuff is necessary for me to do what I want in another file." Almost there! Unfortunately, it would take another 2 months or so for it to sink in and in the meantime, I'd walk around thinking that I had a firm grasp of the concept, and why shouldn't I, my code worked.</p>
<p>Today, I was pairing with Kevin on my TicTacToe game in Clojure. I was trying to understand how I could separate the game logic - code that allowed calculated what move to make, who's turn it was, etc -from the user interface - things like asking the players what their names were, what marker they would like to do, etc. below is my create-players function, which, you guessed it! creates players and exemplifies the issue I'm having with separating the game logic from the user interface.</p>
<p>[code language="clojure"]</p>
<p>(defn create-players [number]<br />
 (cond<br />
(= &quot;1&quot; number) (let [players [{:name (prompt &quot;What is your name?&quot;) :marker (prompt &quot;Select a marker (it can be any letter)&quot;)}<br />
 {:name &quot;TicTacJoe&quot; :marker (prompt &quot;Select a marker for the computer&quot;)}]<br />
 order (prompt &quot;Who will go first? (me/comp)&quot;)]<br />
 (cond<br />
 (= order &quot;me&quot;) players<br />
 (= order &quot;comp&quot;) (reverse players)))</p>
<p>(= &quot;2&quot; number) (let [players [{:name (prompt &quot;Player 1, what is your name?&quot;)<br />
 :marker (prompt &quot;Select a marker (it can be any letter)&quot;)}<br />
 {:name (prompt &quot;Player 2, what is your name?&quot;)<br />
 :marker (prompt &quot;Select a marker (it can be any letter not chosen by player 1)&quot;)}]] players)))</p>
<p>[/code]</p>
<p>So if we called this function - which means that you make the function do what it was created to do - expecting 2 humans to play each other, then we would expect an output like the following:</p>
<p>[code language="clojure"]</p>
<p>[{:name &quot;Jerome&quot; :marker &quot;X&quot;} {:name &quot;Sol&quot; :marker &quot;O&quot;}]</p>
<p>[/code]</p>
<p>We've created a vector that houses two hash maps. The first hash map we can consider to be for player 1. The player's name is Jerome and for this game of Tic Tac Toe he will using the X marker. We infer the similarly about player 2 using the second hash map. The question is how did we get these values?  Do you see all those places in the code where it says "prompt"? That's how.</p>
<p>[code language="clojure"]<br />
(defn prompt [message]<br />
(println message)<br />
(read-line))<br />
[/code]</p>
<p>prompt is a simple function that will print what I type after it and return what the user inputs in response. It's an example of user interface code. It has nothing to do with how the game is run it just gets input from the user and then leaves it up to the game logic to do something with it. The problem is that it doesn't belong in a function like create-players since create-players is a game logic function. So how do we solve this?</p>
<p>Configuration, of course! Let me explain. We know that configuring something means that we arrange a bunch of parts to do something that we want. The parts in this case are the inputs from the users that we get from a multitude of possible locations. In this particular instance there are two we care about:</p>
<ol>
<li>user interface functions like prompt</li>
<li>command line arguments and options parsing (all this means is that when we fire up the TicTacToe from the command line we can add things like -p1 human -p2 computer to specify what type of player, the order of play, etc.) Clojure has a useful tool help with this that I am using.</li>
</ol>
<p>Regardless, of where we get the data, it can't come in raw, our game logic functions are lazy and want all the work done for them. it's excusable, they are doing a lot of other work, they shouldn't have to alter the data so they can use it better too. So we create some new functions that do the work of configuring the raw data into something usable by the game logic functions.</p>
<p>*I haven't written those functions yet, but I may add them at a later date*</p>
<p style="text-align:center;">.  .  .</p>
<p>Writing it out now, the concept of configuration seems so elementary, but I think it's those basic fundamentals that are actually the hardest things to fully grasp. Because they seem so obvious I tend to take them for granted and they cause me a lot of needless frustration in the meantime. I think it get's back to something I talked about in <a href="https://jeromegoodrich.wordpress.com/2016/01/19/the-long-road-day-6/">my post on being stuck</a>. Check the ego at the door, I'm only going to learn something if I admit to myself that I don't know it, and as a result the code will benefit as well.</p>
<p>&nbsp;</p>
