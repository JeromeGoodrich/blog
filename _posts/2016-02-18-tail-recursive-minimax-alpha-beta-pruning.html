---
layout: post
title: Tail Recursive Minimax & alpha-beta pruning
date: 2016-02-18 16:52:08.000000000 -06:00
type: post
published: true
status: publish
categories: []
tags: []
meta:
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '19936468072'
author:
  login: jgoodrich7
  email: jeromegoodrich@gmail.com
  display_name: jgoodrich7
  first_name: ''
  last_name: ''
---
<p>One of the many optimizations that can be made to the minimax algorithm is the inclusion of what's called alpha-beta pruning. In tic-tac-toe, given the current state of the game, Minimax typically works by generating all possible subsequent moves for a player and based on those game states, all possible moves until an end-state (tie, win, loss) is reached at which point the board is "scored". Minimax then works it's way back up the "tree" by comparing the scores of the nodes at each level for each game-state. This <a href="https://www.youtube.com/watch?v=zDskcx8FStA">short video</a> provides a nice visualization for what's happening.</p>
<p>Alpha-Beta pruning improves minimax by eliminating inconsequential "branches" from the minimax search. With less to go through, the algorithm is faster.</p>
<p><img class="alignnone size-full wp-image-1892" src="{{ site.baseurl }}/assets/ab-pruning.png" alt="AB-Pruning" width="640" height="325" /></p>
<p>After tussling with minimax, I feel like I have it down pretty well. So normally, I don't think implementing  alpha-beta pruning would take that long.  I would need to switch my code up a bit, but I have a pretty vivid image of the implementation in my mind. It's a different story when one of the requirements is for the algorithm to also use tail recursion.</p>
<blockquote><p>In <a title="Computer science" href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, a <b>tail call</b> is a <a title="Subroutine" href="https://en.wikipedia.org/wiki/Subroutine">subroutine</a> call performed as the final action of a procedure. If a tail call might lead to the same subroutine being called again later in the call chain, the subroutine is said to be <b>tail-recursive</b>, which is a special case of <a title="Recursion (computer science)" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">recursion</a>. <b>Tail recursion</b> (or <b>tail-end recursion</b>) is particularly useful, and often easy to handle in implementations</p>
<p>-<em>Wikipedia (Tail call)</em></p></blockquote>
<div class="paragraph">
<p>We use tail-recursion in many functional programming languages like Clojure because it doesn't add stack frames to the call stack. Typically, when a function is called the computer must remember the place in the code the function was called from, and this information is stored in the call stack. For complex recursive functions where each call to the function will add a stack frame to the calls stack, the call stack can easily overflow. To get around this we use tail-recursion as it consumes no stack space since the newly called function returns its result to the original caller.</p>
<p>Anyway, tail recursion requires thinking about minimax a bit differently, and specifically I found it helpful to think in terms of the game tree.  In a TicTacToe game, the game tree starts from a root node that corresponds to a particular game-state. All the potential game-states that can result from the root nodes game-state are contained within the children of the root node, these nodes are also called internal nodes. Each internal node has children of it's own up until the point that a terminal state is reached (the leaf node). The pseudo code below attempts to establish some structure and intent around what behavior we should expect from the minimax function:</p>
<p>[code language="clojure"]<br />
;if current-node = root and all children are scored get child with the best score. Return the space associated with that node.<br />
;if current-node is an internal-node, all it's children are scored<br />
  ;and maximizing player's turn get the max score of all it's children<br />
  ;and not maximizing player's turn get the min score of all it's children<br />
;if current-node is internal and depth = 0. Return the score of the node<br />
;if current-node is leaf. Return the score of the node<br />
;if current-node is internal and not all children are scored, score next child.<br />
[/code]</p>
</div>
<div class="paragraph">
<p>In terms of the game tree, the minimax function is trying to get to a node it can score so it can then compare those scores and select the best one. In other words, it's generating new nodes while keeping track of the old ones. At it's heart, that's all that's all the minimax function does.</p>
<p>In Clojure tail recursion is implemented with the special operator <strong>recur.</strong> recur works by accepting the same number of arguments present in the initial function and changing any number of them before returning them to original function.</p>
<pre class="syntaxify">(defn compute-across [func elements value]
  (if (empty? elements)
    value
    (recur func (rest elements) (func value (first elements)))))</pre>
<p>The key to implementing tail recursion is holding the state of what you need to keep track of in the arguments of the original function. for this reason, tail-recursive functions will often have more arguments then their forward recursive counterparts. In the case, of minimax for TicTacToe we need to keep track of nodes we have already "visited" and all the information contained within those nodes. The fact that nodes contain information about the game-state tells me that a node is some sort of nested data structure. Furthermore, given that we each node contains the same types of information with only the values of the information getting changed tells me that one probable implementation of a node could be a hashmap. However, I ended up getting adventurous and using  Clojure's defrecord instead, which is an object but acts similarly to a hashmap.</p>
<p>Here is my implementation of node:</p>
<p>[code language="clojure"](defrecord Node [parent children board depth type markers score])<br />
; board is a hashmap consisting of a game-state and the space the board is space (which can be thought of as a branch ID)[/code]</p>
<p>To be fair, It took a bit of time to figure out what all the information.  stored in a node would be. I had to look back at my original minimax function and identify all the places where the call stack was keeping state, and even then sometimes I had to manipulate certain elements to have them make sense. Eventually, though, I was able to refine the pseudo code to be a bit more explicit before writing things out for real.</p>
<p>[code language="clojure"]<br />
;(defn minimax [node]<br />
; node-score = (get-score (:board node) (:markers node) (:depth node))<br />
; (if (not= nil node-score) or (= depth 0) or (empty? (:children node))<br />
;   (let [score = (:score node) or node-score]<br />
;   elsif root-node<br />
;     get space associated with child that has best score<br />
;     elsif (= (:type node) &amp;quot;max&amp;quot;)<br />
;       if (:score (:parent node)) = nil or score &amp;amp;gt; (:score (:parent node)<br />
;         make (:score (:parent node)) = score<br />
;         else go back up to parent to access next child<br />
;     elsif (= (:type node) &amp;quot;min&amp;quot;)<br />
;       if (:score (:parent node)) = nil or score &amp;amp;lt; (:score (:parent node))<br />
;         make (:score (:parent node)) = score<br />
;         else go back up to parent to access next child<br />
;  else generate the next node and visit it.<br />
[/code]</p>
</div>
<p>From the pseudo code, I think we start to have a pretty good idea of where all our calls to recur might be. It's anywhere where we are modifying the current or visiting another node. The only things left then are implementation details which for me, typically means that it's time to actually write out the code.</p>
<p>[code language="clojure"]<br />
(defn minimax [node]<br />
  (println (:children node))<br />
  (let [current-node-score (score-board (:state (:board node)) (:player-type node) (:depth node))]<br />
      (if (or current-node-score<br />
              (empty? (:children node))<br />
              (= 0 (:depth node)))<br />
        (let [score (or current-node-score (:score node))]<br />
          (if (nil? (:parent node))<br />
            (:space (:board node))<br />
            (if (= (:player-type node) &amp;quot;max&amp;quot;)<br />
              (if (or (nil? (:score (:parent node)))<br />
                      (&amp;gt; score (:score (:parent node))))<br />
                (recur (-&amp;gt; (:parent node)<br />
                           (assoc-in [:score] score)<br />
                           (assoc-in [:board :space] (:space (:board node)))))<br />
                (recur (:parent node)))<br />
              (if (or (nil? (:score (:parent node)))<br />
                      (&amp;lt; score (:score (:parent node))))                 (recur (-&amp;gt; (:parent node)<br />
                           (assoc-in [:score] score)<br />
                           (assoc-in [:board :space] (:space (:board node)))))<br />
                (recur (:parent node))))))<br />
        (let [new-node (Node. (update-in node [:children] rest)<br />
                               (create-possible-boards (:state (first (:children node))) (:markers node))<br />
                               (first (:children node))<br />
                               (dec (:depth node))<br />
                               (if (= (:player-type node) &amp;quot;max&amp;quot;) &amp;quot;min&amp;quot; &amp;quot;max&amp;quot;)<br />
                               (reverse (:markers node))<br />
                               nil)]<br />
          (recur new-node)))))<br />
[/code]</p>
<p>I'd love to say I got figured this out on the first try, but of course it took some debugging and several hours of frustration before getting it to finally work. Having the tests from the original minimax function definitely helped, but it was a lot of printing outputs to the console and checking them against my expectations. Shout out to Jeff R. for his patience and help as a rubber ducky.</p>
<p>With the tail recursive minimax working, all my tests ran in about 45 seconds, up from the 20 seconds they were running at with the original function. This is no good and means that not only is alpha-beta pruning preferential it's necessary.</p>
<p>I mentioned above that alpha-beta pruning works by eliminating inconsequential branches from the minimax search, but what does that actually mean? Let's unpack what's actually going on.</p>
<blockquote><p>The algorithm maintains two values, alpha and beta, which represent the maximum score that the maximizing player is assured of and the minimum score that the minimizing player is assured of respectively. Initially alpha is negative infinity and beta is positive infinity, i.e. both players start with their lowest possible score. It can happen that when choosing a certain branch of a certain node the minimum score that the minimizing player is assured of becomes less than the maximum score that the maximizing player is assured of (beta&lt;=alpha). If this is the case, the parent node should not choose this node, because it will make the score for the parent node worse. Therefore, the other branches of the node do not have to be explored.</p>
<p>-<em>Wikipedia (Alpha-Beta Pruning)</em></p></blockquote>
<p>This tells us 3 things in relation to our current algorithm.</p>
<ol>
<li>We need to update alpha to = the current max-score of the maximizing player</li>
<li>We need to update beta to = the current min-score of the minimizing player</li>
<li>We need to not generate any new nodes if beta &lt;= alpha</li>
</ol>
<p>Looking at the code it's easy to see where these things would happen, and were left with our final result:</p>
<p>[code language="clojure"]<br />
(def minimax (memoize (fn [node]<br />
  (let [current-node-score (score-board (:state (:board node)) (:player-type node) (:depth node))]<br />
      (if (or current-node-score<br />
              (empty? (:children node))<br />
              (= 0 (:depth node))<br />
              (&amp;lt;= (:beta node) (:alpha node)))         (let [score (or current-node-score (:score node))]           (if (nil? (:parent node))             (:space (:board node))             (if (= (:player-type node) &amp;quot;max&amp;quot;)               (if (or (nil? (:score (:parent node))) (&amp;gt; score (:score (:parent node))))<br />
                (recur (-&amp;gt; (:parent node)<br />
                           (assoc-in [:score] score)<br />
                           (assoc-in [:alpha] (max score (:alpha (:parent node))))<br />
                           (assoc-in [:board :space] (:space (:board node)))))<br />
                (recur (:parent node)))<br />
              (if (or (nil? (:score (:parent node)))<br />
                      (&amp;lt; score (:score (:parent node))))                 (recur (-&amp;gt; (:parent node)<br />
                           (assoc-in [:score] score)<br />
                           (assoc-in [:beta] (min score (:beta (:parent node))))<br />
                           (assoc-in [:board :space] (:space (:board node)))))<br />
                (recur (:parent node))))))<br />
        (let [new-node (Node. (update-in node [:children] rest)<br />
                               (create-possible-boards (:state (first (:children node))) (reverse (:markers node)) (:space (first (:children node))))<br />
                               (first (:children node))<br />
                               (:alpha node)<br />
                               (:beta node)<br />
                               (dec (:depth node))<br />
                               (if (= (:player-type node) &amp;quot;max&amp;quot;) &amp;quot;min&amp;quot; &amp;quot;max&amp;quot;)<br />
                               (reverse (:markers node))<br />
                               nil)]<br />
          (recur new-node)))))))<br />
[/code]</p>
<p>One last thing. I used Clojure's memoize function as a way to speed up the code even more. Memoize caches the result of a function call so that when the same inputs occur again it returns the cached result instead of calling the function again, for functions when calls with same arguments are often repeated, there is better performance, but at the cost of higher memory use.</p>
<p style="text-align:center;"><strong>Closing Thoughts</strong></p>
<p style="text-align:left;">I spent the better part of a week figuring out all aspects of this problem, and as such fell behind a bit in writing these posts. I think the length and detail in this post somewhat atones for the lack of consistency as it is pretty much a summary of my thinking over the past week. Parts of me really like these longer form posts. Even though they take up more time and it's unrealistic that I'm able to write one everyday, I'm able to let my thoughts about things marinade and I feel like the quality is much higher.</p>
<div class="paragraph"></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
