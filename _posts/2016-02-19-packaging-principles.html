---
layout: post
title: Packaging Principles Pt. 1
date: 2016-02-19 00:56:58.000000000 -06:00
type: post
published: true
status: publish
categories: []
tags: []
meta:
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '19948997598'
author:
  login: jgoodrich7
  email: jeromegoodrich@gmail.com
  display_name: jgoodrich7
  first_name: ''
  last_name: ''
---
<p>Today I want to talk about Packaging Principles as they are discussed in PPP and Uncle Bob's column in<em> C++ Report</em>. Building off of the SOLID principles and how they apply at the class level of code we must next acknowledge that:</p>
<blockquote><p>As software applications grow in size and complexity they require some kind of high level organization. The class, while a very convenient unit for organizing small applications, is too finely grained to be used as an organizational unit for large applications. Something “larger” than a class is needed to help organize large applications.</p>
<p><em>-</em><em>Robert C. Martin, <em>C++ Report</em>, Nov-Dec 1996</em></p></blockquote>
<p>This larger granule in the context of PPP is called a package. Java jar files, Ruby gems, and javascript libraries can all be thought of as examples of packages. As I understand them, there are two important things to remember about packages:</p>
<ol>
<li>Packages can be thought of a group of classes that are grouped according to some criteria.</li>
<li>A large application will likely have many different packages and those packages will possibly relate to each other in some way.</li>
</ol>
<p>The first 3 packaging principles relate to the concept of package cohesion and deal mostly with identifying what sort of criteria it makes sense to use in order to group packages into packages. While the second 3 packaging principles concern package coupling, or how it makes sense to design an application with regards to the relationship between packages.</p>
<p style="text-align:center;"><strong>Package Cohesion Principles</strong></p>
<p style="text-align:left;">Reuse/Release Equivalency Principle (REP) - <em>the granule of reuse is the granule of release</em></p>
<ul>
<li style="text-align:left;">Reusability comes only after a tracking system is in place and offers the guarantees of notification, safety and support that the potential reusers will need.</li>
<li style="text-align:left;">Reusability is based on packages which are comprised of classes. If a package is reusable <strong>all</strong> the classes it contains must be as well.</li>
<li style="text-align:left;">All classes in a package should be reusable by the same audience.</li>
</ul>
<p>The Common Reuse Principle (CRP) - <em>The classes in a package are reused together. If you reuse one of the classes in a package, you reuse them all.</em></p>
<ul>
<li>Classes that have many dependencies on each other should be in the same package</li>
<li>It should be impossible to depend on some classes of a package and not others</li>
<li>Classes that are not tightly bound to each other with class relationships should not be in the same package.</li>
</ul>
<p>The Common Closure Principle (CCP) - <em></em><em>The classes in a package should be closed together against the same kinds of changes. A change that the affects the package affects all the classes in that package and no other package</em></p>
<ul>
<li>Single Responsibility Principle restated for packages: packages should only have one reason to change</li>
<li>put classes that are likely to change for the same reason in the a package</li>
<li>group together classes that are open to the same types of changes, so when a change in a requirement comes along it will be restricted to a minimal number of packages.</li>
</ul>
<p>I'm going to skip the <strong></strong>Package Coupling principles for now because I don't quite understand them and they aren't particularly relevant at this point in my software career. I have a general awareness of them and I think that's enough for now.</p>
<p>&nbsp;</p>
<p style="text-align:center;">
