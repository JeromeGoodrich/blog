---
layout: post
title: 'The Long Road: Day 19-21'
date: 2016-02-10 21:58:22.000000000 -06:00
type: post
published: true
status: publish
categories: []
tags: []
meta:
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '19677954061'
author:
  login: jgoodrich7
  email: jeromegoodrich@gmail.com
  display_name: jgoodrich7
  first_name: ''
  last_name: ''
---
<p>Here's what I'm stuck on. I'm hoping that writing it out will give me some kind of insight. I have a function, restart-game-maybe that restarts a game if given the correct input from a user.</p>
<p>[code language="clojure"]<br />
(defn restart-game-maybe [game board markers io players]<br />
  (let  [response (get-input io)]<br />
      (if (not= response &quot;y&quot;)<br />
        (exit 0 &quot;See you next time!&quot;)<br />
        (let [new-game (game-loop board players markers io)]<br />
          (restart-game-maybe new-game board markers io players)))))<br />
[/code]</p>
<p>restart-game-maybe is a loop in that it calls itself, which makes it a little difficult to test. Usually the function game-loop will go through it's own loop until the game is over at which point it will return the game end's board to restart-game-maybe. In order to determine whether or not restart-game-maybe function actually calls itself a couple of things need to happen. First, we need to a way to exit the loop, and second we need to see if the function game-loop gets called. Let's tackle the second requirement first.</p>
<p>Normally, if we call the function game-loop it will loop around until that final board is reached. We don't care about that for testing. What we do care about is knowing whether or not the function is actually called. Clojure provides with-redefs to help out a bit. with-redefs basically allows us to redefine a function. This is particularly helpful in mocking out functions for testing. Mocking a function entails simulating it to give a certain behavior so that it's easier to test. </p>
<p>[code language="clojure"]</p>
<p>(defn exit [status message]<br />
  (println status)<br />
  (System/exit status))</p>
<p>(mock-exit [status message]<br />
  status)<br />
[/code]</p>
<p>Since we usually only care about whether exit is being called and not whether System/exit is actually exiting the program, it suffices to see if exit is being called with the correct status. By using with-redefs we can substitute a call to exit with mock-exit and can test against the correct status message being returned. The test below passes.</p>
<p>[code language="clojure"]</p>
<p>(describe &quot;restart-game-maybe&quot;<br />
  (it &quot;correctly exits the game&quot;<br />
    (with-redefs [exit mock-exit]<br />
    (let [game [&quot;X&quot; &quot;O&quot; &quot;X&quot; &quot;O&quot; &quot;X&quot; &quot;O&quot; &quot;X&quot; 7 &quot;O&quot;]<br />
          board [0 1 2 3 4 5 6 7 8]<br />
          markers [&quot;X&quot; &quot;O&quot;]<br />
          io (new-test-console &quot;n&quot;)<br />
          players [(new-human-player io) (new-computer-player 3)]]<br />
      (should= 0 (restart-game-maybe game board markers io players)))))</p>
<p>[/code]</p>
<p>Back to the problem at hand: We want to know whether game-loop is being called but don't care about what it does once it is called. It's an ideal candidate for a with-redefs mocking. What if we did the following?</p>
<p>[code langauge="clojure"]<br />
(def game-loops (atom 0))</p>
<p>(defn mock-game-loop [&amp; args]<br />
  (swap! game-loops inc))</p>
<p>[/code]</p>
<p>Now every time we call mock-game-loop the value of game-loops will increase by 1. we can now run the restart-game-maybe function in our test with game-loop mocked out for mock-game-loop and use (deref game-loops) to see that the mock-game-loop is indeed getting called. One down, one to go. We still need some way to get out of the restart-game-maybe loop.</p>
<p>The easiest way to do this is to have response not equal "y". Let's look at what a test for this might look like.   </p>
<p>[code language="clojure"]<br />
  (it &quot;starts a new game with the same config&quot;<br />
   (with-redefs [exit mock-exit<br />
                 game-loop mock-game-loop]<br />
    (let [game [&quot;X&quot; &quot;O&quot; &quot;X&quot; &quot;O&quot; &quot;X&quot; &quot;O&quot; &quot;X&quot; 7 &quot;O&quot;]<br />
          board [0 1 2 3 4 5 6 7 8]<br />
          markers [&quot;X&quot; &quot;O&quot;]<br />
          io (new-test-console [&quot;y&quot; &quot;n&quot;])<br />
          players [(new-human-player io) (new-computer-player 3)]<br />
          restart-game (restart-game-maybe game board markers io players)]<br />
      (should= 1 @game-loops)))))</p>
<p>[/code]</p>
<p>Our current problem deals with how our binding of io to (new-test-console ["y" "n"]) the idea is that after we loop through restart-game-maybe once we exit the loop by providing an input of "n" instead of "y". How do we do this? If we keep things as is, the input will be ["y" "n"], and thus we won't even loop through once because the only condition we have to satisfy in order to exit is for the input to not be "y". We know a way to access the stuff inside the sequence one at a time, we also know that accessing each piece does not occur at the same time, this rules out things like map. </p>
<p>Let's take a closer look at the the new-test-console function and the TestConsole type it creates. I have a hunch this is where the magic needs to happen. </p>
<p>[code language="clojure"]</p>
<p>(deftype TestConsole [input]<br />
  Presenter<br />
  (print-io [this something])<br />
  (display-end-result [this result markers])<br />
  (get-input [this]<br />
   input)<br />
  (display-board [this board])<br />
  (prompt [this something]<br />
    (get-input this)))</p>
<p>(defn new-test-console [input]<br />
  (TestConsole. input)</p>
<p>[/code]</p>
<p>There's a lot going on here, but the only thing we really need to focus on is the new-test-console function and the get-input function. In this current implementation our input can be anything and whatever it get-input will just return it as is. Clearly something has to change. We have two potential options. Primo, We can try to access different parts of the vector based on whether or not we've looped through the restart-game-maybe function. Secondo, we can change manipulate the input so that it returns what we want. </p>
<p>While you could probably do it the first way, it seems like it would introduce unnecessary complexity and coupling in the code. Here's how we implement the second option and successfully test that restart-game-maybe actually restarts the game when given the right input.<br />
[code language="clojure"]</p>
<p>(deftype TestConsole [input]<br />
  Presenter<br />
  (print-io [this something])<br />
  (display-end-result [this result markers])<br />
  (get-input [this]<br />
   (let [return-this (first @input)]<br />
     (do (swap! input rest)<br />
         return-this)))<br />
  (display-board [this board])<br />
  (prompt [this something]<br />
    (get-input this)))</p>
<p>(defn new-test-console [input]<br />
  (TestConsole. (atom input)))  </p>
<p>[/code]</p>
<p>What's going on here? When we call new-test-console we provide it with an input. that input get's converted into an atom, By doing so, we create an object whose value we can manipulate to suit our needs. When get-input is called we want to return the first value in the vector -- that is now the value of the input atom -- so we use @/deref to access the value. from there we alter the value of the input atom by converting it to a lazy sequence that eliminates the first value of the initial sequence and returns the rest. Now if we call get-input again we will return the next value in the initial sequence. Problem solved and behavior tested.</p>
